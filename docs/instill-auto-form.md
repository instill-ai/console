## We treat all condition field const field type as string instead of literal.

At the first glance, we will think write that condition field is with literal type.

```typescript
// const type
instillZodSchema = z.literal(targetSchema.const as string);
```

However, this approach significantly limits the flexibility of react-hook-form. For instance, suppose a user initially selects TASK_TEXT_GENERATION. When they switch the condition to TASK_IMAGE_GENERATION, the following occurs:

- React hook form changes the field value to TASK_IMAGE_GENERATION.
- onChange validation gets triggered.
- Our form validator schema changes to TASK_IMAGE_GENERATION.

The problem here is that the validation occurs before we update the form validator schema. `TASK_IMAGE_GENERATION` is not a valid value for z.literal(`TASK_TEXT_GENERATION`) with the expectation of TASK_TEXT_GENERATION, resulting in an error: "Invalid literal value, expected 'TASK_TEXT_GENERATION'."

The solution is to avoid using a literal type and instead use a string type. This is because we haven't employed a discriminated union for condition fields, so we won't lose any type safety. Additionally, since each condition field is a single-select generated by us, there's no need to worry about user input.

## How do we implement `instillEditOnNodeFields`

## The object value filter on TextField

```tsx
<Input.Root>
  <Input.Core
    {...field}
    type="text"
    value={
      typeof field.value === "object" ? "" : field.value ?? ""
    }
    autoComplete="off"
    onChange={(e) => {
      field.onChange(e);
      form.trigger(path, { shouldFocus: true });
    }}
    disabled={disabled}
  />
</Input.Root>
```

Sometime when we change the condition, the old value may look like a object for the new fields.

For example, we have a structure like this

```TypeScript
const oldValue = {
  "inputs": {
    "input": {
      query: "hello-world"
    }
  },
  "task": "foo"
}
```

When we switch the condition from `foo` to `bar` we will remove the old value by setting them to null, but we won't really remove this key-value. But the new structure use `inputs.input` as string. So when react-hook-form directly access it, it will display as `Object Object`

```TypeScript
const newValue = {
  "inputs": {
    "input": {
      query: null
    }
  }
  "task": "bar"
}
```

## About the OneOfConditionField characteristic

- When user select another condition, we will immediately trigger the validation. This is due to we want to make sure the user can't submit the form with invalid value and display the error message asap.
